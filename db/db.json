[
    {
        "title": "Express.js Notes",
        "text": "MODULE 11: EXPRESS.JS\n\n\n11 MODSULE 11: EXPRESS.JS\n\n\nExpress.js is a widely used Node.js framework, used to handle different HTTP methods in an API route. Well designed routes help us handle responses when a client makes requests to a specific endpoint or URL. In this module we expand to using the Fetch API to make POST request to an API that we create. We learn how client-side requests are related to server-side responses. \n\n\nNEW VOCABULARY\n- Express.js\n\n\n11 ROADMAP\n\nWHAT YOU SHOULD KNOW AFTER THIS MODULE:\n\n- How to configure an Express.js app to handle GET and POST request.\n- How to configure an Express.js app to serve static files.\n- How to identify how client-side request relate to server-side responses.\n- How to parse optional and required parameters when creating server-side routes.\n- How to implement client-side POST requests to submit form data to a server. \n- How to implement separation of concerns for routing. \n\n\nKEY TOPICS\n\n* Server setup and sendFile \n* API vs. HTML routes \n* req.query and params \n* GET with Fetch API \n* Middleware for static assets \n* Insomnia \n* POST requests and routes \n* Middleware for body parsing \n* POST with Fetch API \n* Data persistence using JSON \n* Modular routing \n* Custom middleware \n* Heroku deployment \n\nCHALLENGE\n\nThis module’s challenge is to create an application using Express.js and persistence storage that will allow users to take notes via a web interface. You’ll create POST and GET routes to add and retrieve notes from persistent storage. The application will feature a sleek interface and demonstrate your knowledge of Express.js and routing. You'll also deploy the Note Taker application to Heroku using the Heroku CLI.\n\n\n11 UP AND RUNNING\n\nTOOLS FOR THIS WEEK\n\n- Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile application. It is considered the de facto standard server framework for Node.js. It is a server. \n- Insomnia is a powerful REST API client that allows us to test APIs and make client side server requests without having to use a browser. \n- Heroku is a cloud application platform that enables developers to build, run, and operate applications entirely in the cloud. Unlike GitHub pages, which only allows you to deploy static sites with HTML pages, Heroic allows you to deploy a server.js file that will run the Node.js. process. You’ll also use the Heroic CLI which will help you deploy apps easily without leaving the command line. \n\nGIT GUIDE VIDEO\n\n- Did not watch video on Git History\n\nFULL-STACK BLOG POST\n\n* 📖 Blog Post: How to Install the Heroku CLI\n* 📖 Blog Post: Heroku Deployment Guide\n* 📖 Blog Post: MySQL Installation Guide\n\n\n11.1 EXPRESS.JS SETUP AND METHODOLOGY\n\n\nWHAT YOU SHOULD KNOW BY THE END OF CLASS\n\n- How to configure an Express.js app to handle GET and POST requests.\n- How to configure an Express.js app to serve static files.\n- How to identify how client-side request relate to server-side responses.\n- How to parse optional and required parameters when creating server-side routes.\n- How to implement client-side POST requests to submit form data to a server.\n- How to implement separation of concerns for routing. \n\n\n11.1 ACTIVITY FILES\n\n- 02-Stu_Setup\n- 04-Stu_API-HTML-Routes\n- 06-Stu)Query-Params\n- 08-Stu_GET-Fetch\n- 10-Stu_Static Assets\n\n\nREVEIW CLASS RECORDING AND TAKE NOTES BELOW:\n\n- Express.js \n    - A lightweight framework for Node.js that allows you to write APIs, handle HTTP request, and implement middleware in your sever-side application. \n    - Express exists on the back end of an application.\n    - Express is conferred the de facto standard for creating routes in Node.js applications\n- What is a Route?\n    - Routes are a lot like traffic lanes at an airpot. Certain lanes are designated for dropping people off, picking up passengers, picking up luggage, and so on. \n    - Similar, routes allow us to send and receive data depending on which route and HTTP method we use. A route can be used for different kinds of requests, to create, read, update, and delete data (CRUD operations). \n        - POST - Submits data to the specified resource, often causing a change on the server.\n        - GET - Retrieves a resource from the server\n        - DELETE - Deletes a specified resource\n        - PUT/PATCH - Updates a specified resource with a payload. \n    - Routes make a request (ex GET, DELETE, POST) from the client side to the server, which returns the request data or updates the server with a response. \n- What is a RESTful API?\n    - REST, or representational state transfer, is an architecture for creating a web service like an API. \n    - Mapping CRUD operations to specific methods in the HTTP and then to specific endpoints to match them with various resources. \n    - RESTful APIs must meet the following criteria:\n        - Comprise clients, servers, resources and request (via HTTP).\n        - Use stateless communications between client and server.\n        - Serve cached objects to reduce bandwidth.\n        - Maintain a uniform interface between the client and the server so that they can evolve separately.\n        - Optionally, can perform code on demand. \n    - What are the HTTP Methods?\n        - POST\n        - GET\n        - DELETE\n        - PUT/PATCH\n    - What does the code look like?\n        - Example of a few Express.js routes:\n            - Use get(), post(), delete() and similar methods to create routes. \n            - The first argument is the path, /api/reviews.\n        - //Get route for static homepage\n        - app.get(‘/‘, (req, res) =>\n            - res.sendFile(‘index.html’);\n        - //Get route for all reviews\n        - app.get(‘/api/reviews, (req, res) =>\n            - res.json(reviewData)\n    - Code snippets continued:\n        - Example of a POST route:\n            - The path is the part of the route that comes after the base URL.\n            - POST routes also accept the path as the first argument.\n            - The second argument is a callback: (req, res) =>{};\n            - // POST route to add a single review\n            - app.post(‘/api/reviews; (req, res) =>{\n            - const newReview = req.body\n                - writeToFile(destination, newReview)\n            - res.json(‘${req.method} received’);\n            - });\n- How does this relate to the front-end?\n    - Client-Side Request\n        - We use the Fetch API to make request to the Express.js server\n        - We can create fetch() request that the server side routes understand and respond to\n        - Post request will send a body that we capture server-side\n- Making fetch() requests will be no different than making calls to a third-party API. The only difference is that this API will run locally. \n- Resolving Request\n    - Request must be concluded to prevent the client application from hanging indefinitely\n    - Methods attached to the response object allow us to conclude a request/response cycle.\n- In order to set up routes in express, one must:\n    - Require Express\n    - Declare the port\n    - Declare the app as the express() call back\n    - Use app with its use() method, with express.static(‘path’) as the parameter to return the static assets resource (likely in your ‘public’ folder).\n    - Lastly, the sever app.listen() method should be called with the 2 parameters being the PORT, and the call back function to let you know the server is working. Example code is as such:\n        - app.listen(PORT, ()=> {console.log(`Now listening on port ${PORT}`)})\n\n\nSTOPPED VIDEO AT 3:47:28\n\n\n11.2 POST REQUEST AND PERSISTENT DATA\n\n\n- In this class you learn how to test API’s using Insomnia. \n- Additionally, you’ll create POST routes on the back end and corresponding fetch() request on the front end. \n- You’ll learn how to use middleware to parse JSON in your applications and how to implement persistent storage for the back end. \n\n\nWHAT YOU SHOULD KNOW BY THE END OF CLASS:\n\n- How to perform HTTP request using Insomnia.\n- How to configure an Express.js app to handle POST requests. \n- How to implement Express.js middleware to be able to read data from a POST request.\n- How to implement client-side POST request to submit form data to a server.\n- How to read and write to a JSON text file. \n\n\n11.2 ACTIVITY FILES\n\nPrior to class, be sure to download the following files:\n\n- 12-Stu_Insomnia\n- 14-Stu_POST-Request\n- 16-Stu_Body-Parsing\n- 18-Stu_POST-Fetch\n- 20-Stu_Data-Persistence\n\n\nREVEIW CLASS RECORDING AND TAKE NOTES BELOW:\n\n- Insomnia a tool that will help us to debug our back end. \n- Insomnia is an open-source and cross-platform graphical API (Application Programming Interface) testing tool. It is designed to simplify the process of testing and interacting with HTTP-based APIs and web services. Insomnia provides a user-friendly interface for developers and testers to send HTTP requests, view responses, and inspect API data. Insomnia docs\n- Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application's request-response cycle.\n    - App.use(express.json()); - used to parse JSON objects passed to the server\n    - app.use(express.urlencoded({extended: true}) - used to parse query strings (?key=value)\n- Static files can be served from a directory designated public using middleware as long as you tell the server to use express’ static method to serve files from the directory you set as a parameter of the static method. The code is written like this:\n    - const express = require(‘express’);\n    - const app = express();\n    - const PORT = 3001;\n    - app.use(express.static(‘directoryName’))\n    - app.listen(PORT, ()=> {console.log(`Server listening at port ${PORT}`)})\n- The req Object includes properties that the server reads to decipher what information to get/retrieve/delete or post/put. \n    - req.method - is the method or CRUD operation being requested of the server\n    - req.body - the body of request object being sent to the server, which is mostly used in post/put methods. \n\nSTOPPED VIDEO AT 03:58:01\n\n\n11.3 MODULAR ROUTING, CUSTOM MIDDLEWARE, AND DEPLOYMENT\n\n- In this class you learn:\n    - How to create modular routes for better organization. \n    - How to write custom middleware and use it for server-side applications. \n    - How to deploy applications to Heroic using the Heroic CLI and explore some lessor know Git commands.\n\n\nWHAT YOU SHOULD KNOW BY THE END OF CLASS:\n\n- How to implement separation of concerns for routing ,\n- How to write a custom middleware function for Express.js,\n- How to deploy a Node.js app to Heroku. \n- How to navigate Git History inside a large open source application.\n\n\n11.3 ACTIVITY FILES\n\nPrior to class, be sure to download the following files:\n\n- 22-Stu_Modular-Routing\n- 24-Stu_Custom-Middleware\n- 26-Stu_Heroku\n- 27-Evr_Git-History\n- 28-Stu_Mini-Project\n\n\nGIT GUIDE VIDEO: GIT HISTORY\n\n- Using git log to explore git history of the inquirer.js repo.\n- To begin:\n    - Clone the inquirer repo into the folder\n    - The cd into the folder\n    - Then type git log packages (packages is a directory in the repo)\n        - The git log command shows the history of the commits that affected only that directory in the repo\n        -  the first item in the log is the commit hash, which is the unique commit id, then the author that wrote the commit, the date that the commit was done, and the commit message\n        - Hit q to exit\n        - Type git log origin/typescript (which allows you to view the log script of the specific branch)\n        - If that branch is not available, you can type git branch -r to see a list of available branches\n        - Hit q to exit\n        - Type git log —no-merges (removes the merge commits from the output)\n        - Hit q to exit\n        - Type git log —since=8am —author=Simon\n        - Hit q to exit\n        - Type git log —before={2020-12-31} —after={2016-12-31} (will show all commits after the date to the before date)\n        - Hit q to exit\n        - Type git log —grep=“prompts”\n        - Hit q to exit\n        - Type git blame package.json (shows a line by line list of changes to the package.json file with the hash, author, date and time stamp, \n        - Choose a commit you want to investigate, copy the hash beginning characters and make note of the commit information\n        - Hit q to exit\n        - Type git checkout (paste the commit hash)\n        - Type git log —grep=“ci”\n        - The git log can potentially tell a story and by learning how to manage git log and git blame you can learn where things went wrong in your repository using these tools built into git\n\n\nREVEIW CLASS RECORDING AND TAKE NOTES BELOW:\n\n- Modularizing routes - splitting the route segments into different modules to create different paths that our request will travel up to resolve different endpoints. \n- The primary purpose of modularizing routes is to improve code organization, maintainability, and readability, especially as your web application grows in complexity. This practice is commonly used in Express.js applications, but the concept can be applied to other web frameworks as well. \n- Custom Modules can be created using middleware (i.e. app.use(‘/api’, api);) where the second parameter is a variable that was set up to import the file path to file containing the routes/endpoints that will be requested that all contain the /api url delimiter & path. \n- When creating custom modules you must include routers in your module files so the server can follow the correct route to the requested resource based on the end points use. Routers are created through creating an instance of the server application (I.e. const = require(‘express)) and calling the Router() method on that instance. Then exporting the route. The code is as follows:\n    - const router = require(‘express’).Router\n    - router.use(‘/endpoint’, require(‘./resourceFilePath’);\n    - Module.exports = router;\n- Heroku is an application platform where we can host our node applications to see them on the web. GitHub does not allow us to run applications on our backend. Heroku allows us to run a full on web application in the web and hosts it so anyone can see it. \n- Activity 25 Heroku Demonstration at 2:04:00\n\nSTOPPED VIDEO AT 2:30:00 DURING EXPLANATION OF MINI-PROJECT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "id": "3444"
    },
    {
        "title": "Node.js Notes",
        "text": "MODULE 09: NODE.JS\n\n\n9 MODULE 09: NODE.JS\n\n- In this and later modules, you learn how to write your own server-side applications to handle requests and ultimately to build your own APIs.\n- In a previous era you would have had to start learning a second programming language, like PHP, to write server-side code, but Node.js, released in 2009, makes this unnecessary as it is an implementation of the V8 JS engine without Chrome and allows you to write server side code using JavaScript. Now you no longer need a browser to run JS as you can do so from the CLI. \n- In this module, you learn how to initialize a node.js  project, install third-party dependencies, and create interactive command line applications. \n- Node.js comes with a standard library that contains a number of modules that allow you to extend the functionality of Node.js, like fs, which you’l use to read and write files. \n- Additionally, you’ll learn how to add a large and robust ecosystem of third-party modules to apps to extend their functionality. \n\n\nNEW VOCABULARY\n\n- Node.js\n- Process.argv\n- fs\n- require()\n- module.exports\n- npm\n- package.json\n- npm init\n- node modules\n- inquirer\n- ES6\n- let\n- const\n- Arrow functions\n- Template literals\n- map() array method\n- filter() array method\n- reduce() array method\n- Spread operator\n- Destruction arrays and objects\n- Asynchronous JS\n- Promises\n- Call backs\n\n\n9 ROADMAP\n\n\nWHAT YOU SHOULD KNOW BY THE END OF THIS MODULE\n\n- How to build interactive command-line applications that process user input\n- How to explain modularization and how it relates to npm and the standard library\n- How to initialize new Node.js projects with npm, and install and import dependencies\n- How to explain the importance and usefulness of ES6+ concepts such as let, const, and arrow functions. \n- How to handle asynchronicity with callbacks and promises \n\n\nKEY TOPICS\n\n* Node.js \n    * process.argv \n    * fs \n* Modularization\n    * require() \n    * module.exports \n* npm \n    * package.json \n    * npm init \n    * node_modules \n* inquirer \n* ES6 \n    * let and const \n    * Arrow functions \n    * Template literals \n    * Array methods—map(), filter(), and reduce() \n    * Spread and rest\n    * Destructuring arrays and objects \n* Asynchronous JavaScript \n    * Callbacks \n    * Promises \n\nCHALLENGE\n\nThis week’s challenge is to create a command-line application that uses input from a user to dynamically generate a quality README for a GitHub project. \n\n\n9 UP AND RUNNING \n\n\nTOOLS FOR THIS WEEK\n\nIn this module you’ll use the following tools:\n\n- Node.js - an asynchronous JavaScript runtime environment that executes JS code outside of a browser. It allows devs to code the back ends of their applications using JS instead of another programming language. Node.js runs script on the server side to produce dynamic webpage content before the page is sent to the user’s browser.\n- npm (Node package manager) - the default package manager for Node.js. It is distributed with Node.js and automatically installed on your CPU when you install Node.js. You will use npm from the command line to add Node.js packages (such as inquirer) to your applications. Each package adds additional functionality that you can include by passing it as an argument to the require function. \n- Inquirer - an embeddable command-line interface for Node.js that makes it easy to ask questions, validate answers, parse input, provide error feedback, and manage hierarchical prompts. It allows you to create interactive menus in your command-line interface applications. \n\n\nGIT GUID VIDEO\n\nGit Guide: Git Fork\n\n- What is a fork? \n    - A fork is a personal copy of someone else’s project. It allows you to make changes to a project without affecting the original project\n    - It also allows you to submit pull request against the original project\n- In order to fork a project we do the following:\n    - Click the fork symbol on the project in GitHub\n    - Select out GitHub username \n    - Copy the code URL to clone to our local IDE with git clone (code url) && cd (repository name)\n    - Next make a feature branch with changes\n    - Stage, commit, and push up to create a pull request\n- Why would you do this?\n    - It allows you to contribute to open source software\n    - Allows you be involved in project you think are worthwhile\n    - If you are treating your work on GitHub as part of your portfolio and resume, it is another way to expand on your resume.\n\n\n09.1 INTRODUCTION TO NODE.JS AND ES6\n\n\nWHAT YOU SHOULD KNOW BY THE END OF CLASS:\n\n- How to explain the client-server model.\n- How to run very simple JavaScript files from the command line using Node.js.\n- How to Explain arrow function and how they impact the this context.\n- How to use template strings and use const and let in place of var.\n- How to use functional loops like map() and filter().\n\n\n09.1 ACTIVITY FILES\n\nIn preparation for class, download the following files from GitLab:\n\n- 02-Stu_Hello-Node\n- 04-Stu_Arrow-Function-Practice\n- 06-Stu_Let-Const\n- 08-Stu_Functional-Loops\n- 10-Stu_Template-Literals\n\n\nREVEIW THE CLASS RECORDING AND TAKE NOTES BELOW:\n\n\n- Client-Side - The three primary components of client-side code are HTML, CSS, and JavaScript. We can also fetch data from an API for use in the client. \n- Sever-Side Dev - include the following:\n    - Node.js\n    - Express.js\n    - MySQL\n- Client - a client is a piece of computer hardware or software that makes request to a server. It can be a desktop computer, laptop, mobile device, and beyond. \n- What is GitHub pages doing?\n    - It’s a file server for the browser so that when the client makes a request for a static resource, it delivers it\n    - It’s just serving files\n    - Server Definition - depending on context, a server is both physical hardware and the software that hears request from users and returns something, like an HTML or image file, or completes a process\n    - The Client-Server Model \n        - In modern web applications, there is constant back and forth communication between the visuals displayed on the user’s browser (the front end) and the data and logic stored on the server (the back end). \n        - Clients make requests, and servers respond.\n    - What is Node.js?\n        - An open source, cross-platform JavaScript runtime environment designed to be run outside of the browser.\n        - It is a general utility that can be used for a variety of purposes including asset compilation, scripting, monitoring, and most notably as the basis for web servers. \n    - Context is similar to scope in that it determines what the this variable references. The this variable references the object that is calling it, unless it is inside of an arrow function, then this inherits the context in which it was created and refers to the object in which it was created. \n    - We should not use arrow functions for object property methods\n    - let vs var vs const\n        - Let is block level scope (only exist in the block in which it is written)\n        - Var is global level scope (exist outside the block in which it is written and scoped to the function or object in which it is declared) \n        - Const cannot change its reference or value once defined\n    - Arrays and Object are passed by reference. Think of them like backpacks, you can’t change backpacks, but you can change the contents of those backpacks\n    - The array.forEach() method transmutes the function by performing an operation on each element in the array; the forEach method takes a function as its argument. \n    - The array.filter() method iterates over an array’s elements, looking for the elements that fit a condition, and then returns a new array of those elements for which the condition is true.\n    - The array.map() method, takes an array with a function to be performed on each element in that array as an argument, and returns a new array with the transformed elements.\n        - Template literals allow you to put mutable objects directly into a string which will return the entire value as a string. Declare template literals with ${variable, function, or object property} and wrap the entire string in back ticks (``)\n\nSTOPPED VIDEO AT 4:15:38\n\n\n09.2 NODE.JS\n\n\nWHAT YOU SHOULD KNOW BY THE END OF CLASS:\n\n- How to run Node.js applications from the command line using arguments. \n- How to import and use the native fs module to read and write to the file system.\n- How to initialize projects and install third-party modules like inquirer using npm. \n- How to use dependencies and investigate the content of package.json. \n\n\n09.2 ACTIVITY FILES\n\nPrior to class, be sure to download the following activity files:\n\n- 12-Stu_Parameter-Check\n- 14-Stu_appendFile\n- 16-Stu_maths\n- 18-Stu_Package-npm\n- 20-Stu_Inquirer-Users\n\n\nREVEIW THE CLASS RECORDING AND TAKE NOTES BELOW:\n\n\n- Process.argv\n    - Node assigns all the command line words to an  array that can be accessed using the process.argv property of the process object. \n    - Argv stands for argument vector, and it is the array arguments, of which the first two elements are reserved for system specific values; the first process.argv[0] being the absolute path to the Node.js executable and the second process.argv[1] being the absolute path to the JS file being executed\n    - The elements in the array beyond the first two are the arguments provided when running the Node.js script from the command line.  \n- You can use the process.argv to check the values of the command scripts passed in the terminals\n- Some Node.js packages are automatically included with node, but in order for our files to have access to them, we must use the require(“package name”); method in our code. We do this by assigning a variable as in: const packageVariable = require(“packageName”);\n- Fs is a Node standard library package for reading and writing files, which can be made available to your code using const variableName = require(“fs”);\n    - fs.readFile() - the readfile(“fileName.format”, “utf8”, function(if any)) method will read a file and and print it to the console. It takes three arguments: the first being the file name to read, second utf8 is a character set that converts the file to readable characters, and the last can be a function used to access and manipulate the data read from the file.\n    - fs.writeFile() - the writeFile() method is used to create an entirely new file in the directory of the js script file that is running it. It takes 3 arguments: the first is the name and format of the file to write/create, the second is what to write in that file, and the last argument is a function that is passed an error if something is incorrect\n    - fs.appendFile() - the appendFile method will add information to a file that is declared if it exist or it will create the file if it does not exist\n- Modularization - the process of breaking up code into independent modules based on their specific uses or functions in order to align code development with the principle of separation of concern, make code reusable, ease development, maintainability, and debugging. \n- One can create their own modules and export objects, functions, and variables using the module.exports = {objectName1, objectName2}; object code within the module for export. Then use the require method to import the module into the file where the dependency is needed. \n- There are 3 types of modules for use in Node.js:\n    - The Node system packages that come with node.\n    - Custom packages we create\n    - Third party external packages from NPM repository \n- NPM is a package repository\n- In order to install npm modules one must initialize a package.json file using npm init or npm init -y (uses default values to create package.json file), so that you can then use npm install or npm i in the command line to install required modules. \n- A common npm package is inquirer, which is used to ask questions in the command line and return a response object of the answers.\n\nSTOPPED VIDEO AT 4:15:13\n\n\n09.3 ADVANCED ES6\n\n\nWHAT YOU SHOULD KNOW BY THE END OF THIS CLASS:\n\n- How to identify and implement how and when two use for…of loops.\n- How to identify and implement how and when to use the spread and rest operators.\n- How to use restructuring assignment syntax to unpack values from arrays, or properties from objects, into unique variables.\n- How to identify and implement how and when to fork a Git repository. \n\n\n09.3 ACTIVITY FILES\n\nPrior to class, be sure to download the following files:O\n\n- 22-Stu_for-of\n- 24-Stu_Rest-and-Spread\n- 26-Stu_Obj-Destructuring\n- 27-Evr_Git-Fork\n- 28-Stu_Mini-Project\n\n\nREVEIW THE CLASS RECORDING AND TAKE NOTES BELOW:\n\n- For..of loops are another way to loop through an array and perform an action to transform or manipulate the data. The syntax of the for…of loop is: for (const arrayName of parameter){function or method};\n- The rest operator (…) is used to pass an undefined number of parameters or elements in an array to a function. The rest operator is used in the function() declaration or expression parameter field as follows: function functionName(…arrayName){function body and return output}. The rest operator creates a new array and not a reference to the old array. \n- The spread operator (…) is used to integrate an array’s elements into another array. It is used before the array name of the array you want to spread in the index of the array you want the array spread in as follows. const array2 = [el1, …array1, el3];\n- Destructuring allows one to pass {object properties} as parameters to a function in order to declare those properties as variables and be able to avoid  referencing the object name in function code. Objects/arrays are destructured as follows: {property1, property2} = objectName/Array or function funcName({property1, property2}){console.log(property1 + “ ”+ property2)} where the name of the object is passed to the function during the callback.\n\nSTOPPED VIDEO AT 3:45:50 DURING CODING OF MINI-PROJECT\n",
        "id": "828e"
    }
]